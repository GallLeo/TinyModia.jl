var documenterSearchIndex = {"docs":
[{"location":"Internal.html#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This chapter documents internal functions that are typically only for use of the developers of package TinyModia.","category":"page"},{"location":"Internal.html#Code-Generation","page":"Internal","title":"Code Generation","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This section provides functions to generate Julia code of the transformed equations.","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"CurrentModule = TinyModia","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"SimulationModel\r\ngenerate_getDerivatives!\r\ninit!\r\noutputs!\r\naddToResult!\r\ngetFloatType\r\nbaseType\r\nmeasurementToString","category":"page"},{"location":"Internal.html#TinyModia.SimulationModel","page":"Internal","title":"TinyModia.SimulationModel","text":"simulationModel = SimulationModel{FloatType}(\n        modelModule, modelName, getDerivatives!, equationInfo, x_startValues,\n        parameters, variableNames;\n        modelModule = nothing,\n        vSolvedWithInitValuesAndUnit::OrderedDict{String,Any}(),\n        vEliminated::Vector{Int}=Int[],\n        vProperty::Vector{Int}=Int[],\n        var_name::Function = v->nothing)\n\nArguments\n\nmodelModule: Module in which @instantiateModel is invoked (it is used for Core.eval(modelModule, ...)), that is evaluation of expressions in the environment of the user.\nmodelName::String: Name of the model\ngetDerivatives::Function: Function that is used to evaluate the model equations, typically generated with [TinyModia.generate_getDerivatives!].\nequationInfo::ModiaBase.EquationInfo: Information about the states and the equations.\nx_startValues:: Deprecated (is no longer used).\nparameters: A hierarchical NamedTuple of (key, value) pairs defining the parameter and init/start values.\nvariableNames: A vector of variable names. A name can be a Symbol or a String.\n\n\n\n\n\n","category":"type"},{"location":"Internal.html#TinyModia.generate_getDerivatives!","page":"Internal","title":"TinyModia.generate_getDerivatives!","text":"code = generate_getDerivatives!(AST, equationInfo, parameters, variables, functionName;\n                                hasUnits=false)\n\nReturn the code of the getDerivatives! function as Expr using the Symbol functionName as function name. By eval(code) or fc = @RuntimeGeneratedFunction(code) the function is compiled and can afterwards be called.\n\nArguments\n\nAST::Vector{Expr}: Abstract Syntax Tree of the equations as vector of Expr.\nequationInfo::ModiaBase.EquationInfo: Data structure returned by `ModiaBase.getSortedAndSolvedAST           holding information about the states.\nparameters: Vector of parameter names (as vector of symbols)\nvariables: Vector of variable names (as vector of symbols). The first entry is expected to be time, so variables[1] = :time.\nfunctionName::Function: The name of the function that shall be generated.\n\nOptional Arguments\n\nhasUnits::Bool: = true, if variables have units. Note, the units of the state vector are defined in equationinfo.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.init!","page":"Internal","title":"TinyModia.init!","text":"success = init!(simulationModel, startTime, tolerance, merge, log, logParameters, logStates)\n\nInitialize simulationModel::SimulationModel at startTime. In particular:\n\nEmpty result data structure.\nMerge parameter and init/start values into simulationModel.\nConstruct x_start.\nCall simulationModel.getDerivatives! once with isInitial = true to compute and store all variables in the result data structure at startTime and initialize simulationModel.linearEquations.\nCheck whether explicitly solved variables that have init-values defined, have the required value after initialization (-> otherwise error).\n\nIf initialization is successful return true, otherwise false.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.outputs!","page":"Internal","title":"TinyModia.outputs!","text":"outputs!(x, t, integrator)\n\nDifferentialEquations FunctionCallingCallback function for SimulationModel that is used to store results at communication points.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.addToResult!","page":"Internal","title":"TinyModia.addToResult!","text":"addToResult!(simulationModel, variableValues...)\n\nAdd variableValues... to simulationModel::SimulationModel. It is assumed that the first variable in variableValues is time.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.getFloatType","page":"Internal","title":"TinyModia.getFloatType","text":"floatType = getFloatType(simulationModel::SimulationModel)\n\nReturn the floating point type with which simulationModel is parameterized (for example returns: Float64, Float32, DoubleFloat, Measurements.Measurement{Float64}).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.baseType","page":"Internal","title":"TinyModia.baseType","text":"baseType(T)\n\nReturn the base type of a type T.\n\nExamples\n\nbaseType(Float32)                # Float32\nbaseType(Measurement{Float64})   # Float64\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.measurementToString","page":"Internal","title":"TinyModia.measurementToString","text":"str = measurementToString(v)\n\nReturn variable v::Measurements.Measurement{FloatType} or a vector of such variables in form of a string will the full number of significant digits.\n\n\n\n\n\n","category":"function"},{"location":"Tutorial.html#TinyModia-Tutorial","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"","category":"section"},{"location":"Tutorial.html#Introduction","page":"TinyModia Tutorial","title":"1 Introduction","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"This tutorial gives an overview of package TinyModia to construct component-based and equation-based models with the TinyModia language on a high level, symbolically transforming these models into ODEs (Ordinary Differential Equations in state space form), simulating them and plotting result variables.","category":"page"},{"location":"Tutorial.html#Modeling","page":"TinyModia Tutorial","title":"2 Modeling","text":"","category":"section"},{"location":"Tutorial.html#.1-Equation-oriented-models","page":"TinyModia Tutorial","title":"2.1 Equation oriented models","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A simple differential equation with x(t) in R","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"T cdot fracdxdt + x = 2  x(t_0) = 05","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"can be defined with a constructor Model taking a comma separated list of name/value pairs:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    using TinyModia\r\n\r\n    SimpleModel = Model(\r\n        T = 0.2,\r\n        x = Var(init=0.5),\r\n        equation = :[T * der(x) + x = 2],\r\n    )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The model consist of a definition of a parameter T with default value 0.2, constructor Var with an init key is used to define the initial condition 0.5 of the state x, and one equation. Equations can have a Julia expression on both sides of the equal sign and are given as a quoted array expression :[ ] assigned to a unique identifier such as equation. The equation will be symbolically solved for the derivative der(x) before simulation, so the following equation will be used for the integration:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"fracdxdt = (2 - x)  T","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A low pass filter block with input u and output y","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     y = x \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"can be defined as:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    using ModiaBase\r\n\r\n    LowPassFilter = Model(\r\n        T = 0.2,\r\n        u = input,\r\n        y = output | Var(:x),\r\n        x = Var(init=0),\r\n        equation = :[T * der(x) + x = u],\r\n    )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The symbols input and output refer to predefined variable constructors to define the input and output variables. If an equation has just a unique variable in the left hand side, y, the right hand side can be given as a quoted expression in a Var-constructor Var(:x) after the output constructor combined with the merge operator, |, see below.","category":"page"},{"location":"Tutorial.html#.2-Merging-models","page":"TinyModia Tutorial","title":"2.2 Merging models","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"It is possible to combine models by merging. If we want to change the model to become a highpass filter, an alternative output equation","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"y = -x + u","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"is defined in an anonymous model Model( y = :(-x + u) ). This anonymous model is merged with LowPassFilter using the merge operator |:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"HighPassFilter = LowPassFilter | Model( y = :(-x + u) )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The merging implies that the output property of y is kept, but the binding expression is changed from :x to :(-x + u).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In general, recursive merging is desired and TinyModia provides a mergeModels function for that (see appendix A.3 MergeModels algorithm). This function is invoked as a binary operator | (also used for merge in Python). Note, that the order of the arguments/operands are important.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Generalizing the block to have two outputs for both low and high pass filtering would be done as follows:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"LowAndHighPassFilter = LowPassFilter | Model(\r\n        y = nothing,\r\n        low = output | Var(:x),\r\n        high = output | Var(:(-x + u)),\r\n    )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The equation for y is removed by \"assigning\" nothing and two variables are defined and declared as outputs.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Model LowAndHighPassFilter represents the following equations:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     low = x \r\n    high = -x + u \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"By turning on logging of merging setLogMerge(true), the translator gives the log:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Adding: value = :(x)\r\nAdding: value = :(-x + u)\r\nDeleting: y\r\nAdding: low = Var(\r\n      output = true,\r\n      value = :(x),\r\n    ),\r\nAdding: high = Var(\r\n      output = true,\r\n      value = :(-x + u),\r\n    ),","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The resulting model is pretty printed by calling @showModel(LowAndHighPassFilter):","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"LowAndHighPassFilter = Model(\r\n  T = 0.2,\r\n  u = Var(\r\n    input = true,\r\n  ),\r\n  x = Var(\r\n    init = 0.0 V,\r\n  ),\r\n  equations = :([T * der(x) + x = u]),\r\n  low = Var(\r\n    output = true,\r\n    value = :(x),\r\n  ),\r\n  high = Var(\r\n    output = true,\r\n    value = :(-x + u),\r\n  ),\r\n),","category":"page"},{"location":"Tutorial.html#.3-Functions-and-tables","page":"TinyModia Tutorial","title":"2.3 Functions and tables","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In order to test an input/output block as defined in the previous section, an input needs to be defined. This can be made by adding an equation for u. Assume we want u to be sinousoidial with an increasing frequency:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"using Unitful\r\n\r\nTestLowAndHighPassFilter = LowAndHighPassFilter | Model(\r\n        u = :(sin( (time+1u\"s\")*u\"1/s/s\" * time)*u\"V\"),\r\n        x = Var(init=0.2u\"V\")\r\n    )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"time is a reserved name for the independent variable. It has unit s for seconds. The Julia package Unitful provides a means for defining units and managing unit inference. Definition of units is done with a string macro u\"...\". In this case, the input signal was given unit Volt. The state x must then also have consistent unit, that is Volt. If the model equations contain systems of simultaneous equations, then approximate guess values, optionally with units, must be given start: i = Var(start=0.0u\"A\").","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The input signal can also be defined by interpolation in a table:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"using Interpolations\r\n\r\ntable = CubicSplineInterpolation(0:0.5:2.0, [0.0, 0.7, 2.0, 1.8, 1.2])\r\nTestLowAndHighPassFilter2 = TestLowAndHighPassFilter | Map(u = :(table(time*u\"1/s\"))*u\"V\"","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A function cannot return more as one variable and a function cannot modify one of its arguments:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"equations = :[\r\n    (y1, y1) = fc1(u1,u2)      # Error: Two return arguments\r\n    fc2!(u,y)                  # Error: Not known that fc2! computes y\r\n    println(\"This is a test\")  # Fine\r\n]","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The first issue can be fixed by rewriting the function call:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"equations = :[\r\n    v  = fc1(u1,u2)\r\n    y1 = v[1]\r\n    y2 = v[2]\r\n]","category":"page"},{"location":"Tutorial.html#.4-Hierarchical-modeling","page":"TinyModia Tutorial","title":"2.4 Hierarchical modeling","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Sofar, the composition of models have resulted in named tuples with values being numeric values or quoted expressions. Hierarchical models are obtained if the values themself are named tuples. A model with two filters can, for example, be defined as follows:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TwoFilters = (\r\n    high = HighPassFilter,\r\n    low = LowPassFilter,\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Note, that the previous definitions of HighPassFilter and LowPassFilter was used instead of making the defintions inline.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A band pass filter is a series connection of a high pass filter and a low pass filter and can be described as:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"BandPassFilter = (\r\n    u = input,\r\n    y = output,\r\n    high = HighPassFilter | Map(T=0.5, x=Var(init=0.1u\"V\")),\r\n    low = LowPassFilter | Map(x=Var(init=0.2u\"V\")),\r\n    equations = :[\r\n        high.u = u,\r\n        low.u = high.y,\r\n        y = low.y]\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A new input have been defined which is propagated to high.u. The series connection itself is obtained by the equation low.u = high.y. Note, that dot-notation is allowed in equations.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The input and output for the BandPassFilter when using the same input definition as for the TestLowPassFilter is shown below:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: Band Pass Filter Plot)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The above examples are available in file SimpleFilters.jl.","category":"page"},{"location":"Tutorial.html#.5-Physically-oriented-modeling","page":"TinyModia Tutorial","title":"2.5 Physically oriented modeling","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Sofar, only signal flow modeling has been used, i.e. input/output blocks coupled with equations between outputs and inputs. For object oriented modeling more high level constructs are neccessary. Coupling is then acausal and involves potentials such as electric potential, positions, pressure, etc. and flows such as electric current, forces and torques and mass flow rate.","category":"page"},{"location":"Tutorial.html#.5.1-Connectors","page":"TinyModia Tutorial","title":"2.5.1 Connectors","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Models which contain any flow variable, i.e. a variable having an attribute flow=true, are considered connectors. Connectors must have equal number of flow and potential variables, i.e. variables having an attribute potential=true, and have matching array sizes. Connectors may not have any equations. An example of an electrical connector with potential (in Volt) and current (in Ampere) is shown below.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Pin = Model( v = potential, i = flow )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"potential is a shortcut for Var(potential=true) and similarly for flow.","category":"page"},{"location":"Tutorial.html#.5.2-Components","page":"TinyModia Tutorial","title":"2.5.2 Components","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Components are declared in a similar ways as blocks. However, the interfaces between components are defined using connector instances.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"An electrical resistor can be descibed as follows:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Resistor = Model(\r\n    R = 1.0u\"Ω\",\r\n    p = Pin,\r\n    n = Pin,\r\n    equations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i\r\n        R*i = v ]\r\n    )","category":"page"},{"location":"Tutorial.html#.5.3-Inheritance","page":"TinyModia Tutorial","title":"2.5.3 Inheritance","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Various physical components sometimes share common properties. One mechanism to handle this is to use inheritance. In TinyModia, merging is used.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Electrical components such as resistors, capacitors and inductors are categorized as oneports which have two pins. Common properties are: constraint on currents at the pins and definitions of voltage over the component and current through the component.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"OnePort = Model(\r\n    p = Pin,\r\n    n = Pin,\r\n    partialEquations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i ] )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Having such a OnePort definition makes it convenient to define electrical component models by merging OnePort with specific parameter definitions with default values and equations:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Resistor = OnePort | Model( R = 1.0u\"Ω\", equation = :[ R*i = v ], )\r\n\r\nCapacitor = OnePort | Model( C = 1.0u\"F\", v=Map(init=0.0u\"V\"), equation = :[ C*der(v) = i ] )\r\n\r\nInductor = OnePort | Model( L = 1.0u\"H\", i=Map(init=0.0u\"A\"), equation = :[ L*der(i) = v ] )\r\n\r\nConstantVoltage = OnePort | Model( V = 1.0u\"V\", equation = :[ v = V ] )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The merged Resistor is shown below:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Resistor = Model(\r\n  p = Model(\r\n    v = Var(\r\n      potential = true,\r\n    ),\r\n    i = Var(\r\n      flow = true,\r\n    ),\r\n  ),\r\n  n = Model(\r\n    v = Var(\r\n      potential = true,\r\n    ),\r\n    i = Var(\r\n      flow = true,\r\n    ),\r\n  ),\r\n  partialEquations = :([v = p.v - n.v; 0 = p.i + n.i; i = p.i]),\r\n  R = 1.0 Ω,\r\n  equations = :([R * i = v]),\r\n),","category":"page"},{"location":"Tutorial.html#.5.4-Connections","page":"TinyModia Tutorial","title":"2.5.4 Connections","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Connections are described as an array of tuples listing the connectors that are connected:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    ( <connect reference 1>, <connect reference 2>, ... )","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A connect reference has either the form 'connect instance name' or 'component instance name'.'connect instance name' with 'connect instance name' being either a connector instance, input or output variable.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Examples","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    connect = :[\r\n      (V.p, R1.p)\r\n      (R1.n, p)\r\n      (C1.n, V.n, R2.p)\r\n      ...\r\n    ]","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"For connectors, all the potentials of the connectors in the same connect tuple are set equal and the sum of all incoming flows to the model are set equal to the sum of the flows into sub-components.","category":"page"},{"location":"Tutorial.html#.5.5-Connected-models","page":"TinyModia Tutorial","title":"2.5.5 Connected models","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Having the above electrical component models, enables defining a filter","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: Filter Circuit)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"by instanciating components, setting parameters and defining connections.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Filter = (\r\n    R = Resistor | Map(R=0.5u\"Ω\"),\r\n    C = Capacitor | Map(C=2.0u\"F\"),\r\n    V = ConstantVoltage | Map(V=10.0u\"V\"),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The connect tuples are translated to:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"  V.p.v = R.p.v\r\n  0 = V.p.i + R.p.i\r\n  R.n.v = C.p.v\r\n  0 = R.n.i + C.p.i\r\n  C.n.v = V.n.v\r\n  0 = C.n.i + V.n.i","category":"page"},{"location":"Tutorial.html#.5.6-Parameter-propagation","page":"TinyModia Tutorial","title":"2.5.6 Parameter propagation","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Hierarchical modification of parameters is powerful but sometimes a bit inconvenient. It is also possible to propagate parameters intoduced on a high level down in the hierarchy. The following Filter model defines three parameters, r, c and v. The r parameter is used to set the resistance of the resistor R: Map(R=:r).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Filter2 = Model(\r\n    r = 2.0u\"Ω\",\r\n    c = 1.0u\"F\",\r\n    v = 10u\"V\",\r\n    R = Resistor | Map(R=:r),\r\n    C = Capacitor | Map(C=:c),\r\n    V = ConstantVoltage | Map(V=:v),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Two separate filters can then be defined with:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TwoFilters = Model( f1 = Filter | Map( r = 10.0, c = 2.0), f2 = Filter )","category":"page"},{"location":"Tutorial.html#.5.7-Redeclarations","page":"TinyModia Tutorial","title":"2.5.7 Redeclarations","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"It is possible to reuse a particular model topology by redeclaring the model of particular components. For example, changing the filter f1 to a voltage divider by changing C from a Capacitor to a Resistor. A predefined model Redeclare is used for this purpose.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"VoltageDividerAndFilter = TwoFilters | Map(f1 = Map(C = Redeclare | Resistor | Map(R = 20.0)))","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"By using Redeclare, a new model based on a Resistor is used for C and the usual merge semantics with the previously defined model of C is not used.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The above examples are available in file FilterCircuit.jl.","category":"page"},{"location":"Tutorial.html#.5.8-Drive-train-example","page":"TinyModia Tutorial","title":"2.5.8 Drive train example","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A larger example that utilizes most of the previously described features of TinyModia is available as $(TinyModia.path)/examples/ServoSystem.jl. This is a textual (TinyModia) representation of a Modelica model","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: ServoSystem)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"and demonstrates how to build up a hierarchical, multi-domain model consisting of a servo-system with a load, where the servo-system consists of an electric motor with a current and speed controller, as well with a more detailed model of a gearbox.","category":"page"},{"location":"Tutorial.html#.6-Arrays","page":"TinyModia Tutorial","title":"2.6 Arrays","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Model parameters and variables can be arrays. For example a linear state space system with boldsymbolx(t) in R^n_x boldsymbolu(t) in R^n_u boldsymboly(t) in R^n_y  boldsymbolA in R^n_x times n_x boldsymbolB in R^n_x times n_u  boldsymbolC in R^n_y times n_x boldsymbolD in R^n_y times n_u","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"beginaligned\r\nfracdboldsymbolxdt = boldsymbolA cdot boldsymbolx + boldsymbolB cdot boldsymbolu\r\n            boldsymboly = boldsymbolC cdot boldsymbolx + boldsymbolD cdot boldsymbolu\r\nendaligned","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"can be defined as:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"StateSpace = Model(\r\n    A = fill(0.0,0,0),\r\n    B = fill(0.0,0,0),\r\n    C = fill(0.0,0,0),\r\n    D = fill(0.0,0,0),\r\n    u = input,\r\n    y = output,\r\n    x = Var(init = zeros(0)),\r\n    equations = :[\r\n        der(x) = A*x + B*u\r\n             y = C*x + D*u\r\n    ]\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"and used as:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"col(args...) = hvcat(1, args...)  # Construct a column matrix from a vector\r\n\r\nSecondOrder = Model(\r\n    w = 20.0,\r\n    D =  0.1,\r\n    k =  2.0,\r\n    sys = StateSpace | Map(A = :([  0        1;\r\n                                 -w^2  -2*D*w]),\r\n                           B = :(col([0; w^2])),\r\n                           C = :([k 0]),\r\n                           D = :(zeros(1,1)),\r\n                           x = Var(init = zeros(2)) ),\r\n    equations = :[sys.u = [1.0]]\r\n)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Variables sys.u and sys.y are vectors with one element each.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Note, [0; w^2] is a vector in Julia and not a column matrix (see the discussion here). In order that B is defined as column matrix, the function col(..) is used.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Array equations remain array equations during symbolic transformation and in the generated code, so the code is both compact and efficient. In order that this is reasonably possible, the definition of an array cannot be split in different statements:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"equations = :[             # error, vector v is not defined as one symbol\r\n    m1*der(v[1]) = 2.0\r\n    m2*der(v[2]) = 3.0\r\n]","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"If scalar equations are needed in which arrays are used, then the arrays have to be first defined and then elements can be used.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"v = Var(init=zeros(2)),\r\nequations = :[\r\n    a = der(v)\r\n    a1 = a[1]\r\n    a2 = a[2]\r\n    m1*a1 = 2.0\r\n    m2*a2 = 3.0\r\n]","category":"page"},{"location":"Tutorial.html#.7-Model-libraries","page":"TinyModia Tutorial","title":"2.7 Model libraries","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TinyModia provides a small set of pre-defined model components in directory $(TinyModia.path)/models:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"AllModels.jl - Include all model libraries\nBlocks.jl - Input/output control blocks\nELectric.jl - Electric component models\nHeatTransfer.jl - 1D heat transfer component models\nRotational.jl - 1D rotational, mechanical component models","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The circuit of section 2.5.5 Connected models can be for example constructed with these libraries in the following way:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"using TinyModia\r\n\r\ninclude(\"$(TinyModia.path)/models/AllModels.jl\")\r\n\r\nFilterCircuit = Model(\r\n    R = Resistor | Map(R=0.5u\"Ω\"),\r\n    C = Capacitor | Map(C=2.0u\"F\", v=Var(init=0.1u\"V\")),\r\n    V = ConstantVoltage | Map(V=10.0u\"V\"),\r\n    ground = Ground,\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n, ground.p)\r\n    ]\r\n)\r\n\r\nfilterCircuit = @instantiateModel(FilterCircuit)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"It is planned to support a much larger set of predefined model components in the future.","category":"page"},{"location":"Tutorial.html#Simulation","page":"TinyModia Tutorial","title":"3 Simulation","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A particular model is instantiated, simulated and results plotted with the commands:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    using ModiaBase\r\n    using ModiaPlot\r\n\r\n    filter = @instantiateModel(Filter)\r\n    simulate!(filter, stopTime=10.0)\r\n    plot(filter, \"y\", figure=1)","category":"page"},{"location":"Tutorial.html#.1-Instantiating","page":"TinyModia Tutorial","title":"3.1 Instantiating","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The @instantiateModel macro takes additional arguments:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"modelInstance = @instantiateModel(model;\r\n                    FloatType = Float64, aliasReduction=true, unitless=false,\r\n                    log=false, logModel=false, logDetails=false, logStateSelection=false,\r\n                    logCode=false, logExecution=false, logTiming=false)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The macro performs structural and symbolic transformations, generates a function for calculation of derivatives suitable for use with DifferentialEquations.jl and returns modelInstance::SimulationModel that can be used in other functions, for example to simulate or plot results:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"model: model (declarations and equations).\nFloatType: Variable type for floating point numbers (see below).\naliasReduction: Perform alias elimination and remove singularities.\nunitless: Remove units (useful while debugging models and needed for MonteCarloMeasurements).\nlog: Log the different phases of translation.\nlogModel: Log the variables and equations of the model.\nlogDetails: Log internal data during the different phases of translation.\nlogStateSelection: Log details during state selection.\nlogCode: Log the generated code.\nlogExecution: Log the execution of the generated code (useful for finding unit bugs).\nlogTiming: Log timing of different phases.\nreturn modelInstance prepared for simulation","category":"page"},{"location":"Tutorial.html#.2-Simulating","page":"TinyModia Tutorial","title":"3.2 Simulating","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The simulate! function performs one simulation with DifferentialEquations.jl using the default integrator that this package automatically selects and stores the result in modelInstance.  It is also possible to specify the integrator as second argument of simulate!:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    using ModiaBase\r\n    using DifferentialEquations\r\n    using ModiaPlot\r\n\r\n    filter = @instantiateModel(Filter)\r\n    simulate!(filter, Tsit5(), stopTime=10.0, merge=Map(T=0.5, x=0.8))\r\n    plot(filter, [\"y\", \"x\"], figure=1)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Integrator DifferentialEquations.Tsit5 is an adaptive Runge-Kutta method of order 5/4 from Tsitouras. There are > 100 ODE integrators provided. For details, see here.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Parameters and init/start values can be changed with the merge keyword. The effect is the same, as if the filter would have been instantiated with:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    filter = @instantiateModel(Filter | Map(T=0.5, x=Var(init=0.8))","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Note, with the merge keyword in simulate!, init/start values are directly given as a value (x = 0.8) and are not defined with Var(..).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Function simulate! returns the value that is returned by function DifferentialEquations.solve. Functions of DifferentialEquations that operate on this return argument can therefore also be used on the return argument of simulate!.","category":"page"},{"location":"Tutorial.html#.3-Plotting","page":"TinyModia Tutorial","title":"3.3 Plotting","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The plot function generates a line plot with GLMakie.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"A short overview of the most important plot commands is given in section section Plotting","category":"page"},{"location":"Tutorial.html#.4-State-selection-(DAEs)","page":"TinyModia Tutorial","title":"3.4 State selection (DAEs)","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TinyModia has a sophisticated symbolic engine to transform high index DAEs (Differential Algebraic Equations) automatically to ODEs (Ordinary Differential Equations in state space form). During the transformation, equations might be analytically differentiated and code might be generated to solve linear equation systems numerically during simulation. The current engine cannot transform a DAE to ODE form, if the DAE contains nonlinear algebraic equations. There is an (internal) prototype available to transform nearly any DAE system to a special index 1 DAE system that can be solved with standard DAE integrators. After a clean-up phase, this engine will be made publicly available at some time in the future. Some of the algorithms used in TinyModia are described in Otter and Elmqvist (2017). Some algorithms are not yet published.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Usually, the symbolic engine is only visible to the modeler, when the model has errors, or when the number of ODE states is less than the number of DAE states. The latter case is discussed in this section.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The following object diagram shows two rotational inertias that are connected by an ideal gear. One inertia is actuated with a sinusoidal torque:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: TwoInertiasAndIdealGear)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In order to most easily understand the issues, this model is provided in a compact, \"flattened\" form:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TwoInertiasAndIdealGearTooManyInits = Model(\r\n    J1    = 50,\r\n    J2    = 100,\r\n    ratio = 2,\r\n    f     = 3, # Hz\r\n\r\n    phi1 = Var(init = 0.0), # Absolute angle of inertia1\r\n    w1   = Var(init = 0.0), # Absolute angular velocity of inertia1\r\n    phi2 = Var(init = 0.0), # Absolute angle of inertia2\r\n    w2   = Var(init = 0.0), # Absolute angular velocity of inertia2\r\n\r\n    equations = :[\r\n        tau = 2.0*sin(2*3.14*f*time/u\"s\")\r\n\r\n        # inertia1\r\n        w1 = der(phi1)\r\n        J1*der(w1) = tau - tau1\r\n\r\n        # ideal gear\r\n        phi1 = ratio*phi2\r\n        ratio*tau1 = tau2\r\n\r\n        # inertia2\r\n        w2 = der(phi2)\r\n        J2*der(w2) = tau2\r\n    ]\r\n)\r\n\r\ndrive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits)\r\nsimulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true)\r\nplot(drive1, [(\"phi1\", \"phi2\"), (\"w1\", \"w2\")])","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The option logStates=true results in the following output:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"... Simulate model TwoInertiasAndIdealGearTooManyInits\r\n\r\n│ # │ state  │ init │ unit │ nominal │\r\n├───┼────────┼──────┼──────┼─────────┤\r\n│ 1 │ phi2   │ 0.0  │      │ NaN     │\r\n│ 2 │ w2     │ 0.0  │      │ NaN     │","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"This model translates and simulates without problems.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Changing the init-value of w2 to 1.0 and resimulating:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"simulate!(drive1, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"results in the following error:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"... Simulate model TwoInertiasAndIdealGearTooManyInits\r\n\r\n│ # │ state │ init │ unit │ nominal │\r\n├───┼───────┼──────┼──────┼─────────┤\r\n│ 1 │ phi2  │ 0.0  │      │ NaN     │\r\n│ 2 │ w2    │ 1.0  │      │ NaN     │\r\n\r\n\r\nError from simulate!:\r\nThe following variables are explicitly solved for, have init-values defined\r\nand after initialization the init-values are not respected\r\n(remove the init-values in the model or change them to start-values):\r\n\r\n│ # │ name │ beforeInit │ afterInit │\r\n├───┼──────┼────────────┼───────────┤\r\n│ 1 │ w1   │ 0.0        │ 2.0       │","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The issue is the following:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Every variable that is used in the der operator is a potential ODE state. When an init value is defined for such a variable, then TinyModia either utilizes this initial condition (so the variable has this value after initialization), or an error is triggered, as in the example above.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The model contains the equation:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"phi1 = ratio*phi2","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"So the potential ODE states phi1 and phi2 are constrained, and only one of them can be selected as ODE state, and the other variable is computed from this equation. Since parameter ratio can be changed before simulation is started, it can be changed also to a value of ratio = 0. Therefore, only when phi2 is selected as ODE state, phi1 can be uniquely computed from this equation. If phi1 would be selected as ODE state, then a division by zero would occur, if ratio = 0, since phi2 = phi1/ratio. For this reason, TinyModia selects phi2 as ODE state. This means the init value of phi1 has no effect. This is uncritical, as long as initialization computes this init value from the constraint equation above, as done in the example above.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"When differentiating the equation above:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"der(phi1) = ratio*der(phi2)  # differentiated constraint equation\r\n       w1 = der(phi1)\r\n       w2 = der(phi2)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"it becomes obvious, that there is also a hidden constraint equation for w1, w2:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"w1 = ratio*w2  # hidden constraint equation","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Again, TinyModia selects w2 as ODE state, and ignores the init value of w1. In the second simulation, the init value of w1 (= 0.0) is no longer consistent to the init value of w2 (= 1.0). Therefore, an error occurs.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The remedy is to remove the init values of phi1, w1 from the model:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"drive2 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits |\r\n                                Map(phi1 = Var(init=nothing),\r\n                                    w1   = Var(init=nothing)) )\r\nsimulate!(drive2, Tsit5(), stopTime = 1.0, logStates=true, merge = Map(w2=1.0))","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"and simulation is successful!","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"TinyModia tries to respect init values during symbolic transformation. In cases as above, this is not possible and the reported issue occurs. In some cases, it might not be obvious, why TinyModia selects a particular variable as an ODE state. You can get more information by setting logStateSelection=true:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"drive1 = @instantiateModel(TwoInertiasAndIdealGearTooManyInits, logStateSelection=true)","category":"page"},{"location":"Tutorial.html#Floating-point-types","page":"TinyModia Tutorial","title":"4 Floating point types","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The types of the floating point numbers in a TinyModia model can be parameterized with argument FloatType of macro @instantiateModel:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    filter = @instantiateModel(Filter; FloatType = Float64)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"By default, a floating point number has type Float64.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"warning: Warning\nUsing another floating point type requires that a DifferentialEquations.jl integrator is used that is implemented in native Julia. An integrator that interfaces an integrator implemented in C (such as CVODE_BDF() the popular Sundials BDF method), cannot be used.","category":"page"},{"location":"Tutorial.html#.1-Lower-and-higher-precision","page":"TinyModia Tutorial","title":"4.1 Lower and higher precision","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In principal, any floating point type of Julia (so any type that is derived from AbstractFloat) can be used in the model and the integrators. Examples","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Type Precision Package Usage\nFloat32 7 digits built-in Embedded system\nFloat64 16 digits built-in Offline simulation\nDouble64 30 digits DoubleFloats High precision needed\nBigFloat arbitrary built-in Very high precision needed (very slow)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The Float32 type might be used to test the execution and numerics of a model that shall later run on an embedded system target (there is no automatic way, yet, to translate a TinyModia model to C).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Double64 is a type that is constructed from two Float64 types. The execution is much faster as the comparable Julia built-in type BigFloat when set to 128 bit precision. The Double64 type might be used, when simulation with Float64 fails due to numerical reasons (for example the model is very sensitive, or equation systems are close to singularity) or when very stringent relative tolerances are needed, for example relative tolerance = 1e-15 as needed for some space applications.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In the following example, simulation is performed with a Float32 floating point type used for model and integrator and utilizing a Runge-Kutta integrator of order 4 with a fixed step size of 0.01 s:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"    filter = @instantiateModel(Filter, FloatType = Float32)\r\n    simulate!(filter, RK4(), adaptive=false, stopTime=10.0, interval=0.01)","category":"page"},{"location":"Tutorial.html#.2-Uncertainties","page":"TinyModia Tutorial","title":"4.2 Uncertainties","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Package Measurements provides a floating point type designed for error propagation. A floating point number is defined with a nominal value and an uncertainty:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"using Measurements\r\n\r\nm1 = 2.1 ± 0.4\r\nm2 = 2*m1           # 4.2 ± 0.8\r\nm3 = m2 - m1        # 2.1 ± 0.4","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The statement m1 = 2.1 ± 0.4 defines that m1 has a nominal value of 2.1 with a standard deviation of 0.4. This means that the probability is about 95 % that the value of m1 is in the range 1.3 .. 2.9. Package Measurements computes the error propagation with first-order theory (so this is typically an approximation) by computing the partial derivatives of all variables with respect to all source error definitions and computing the propagated error with this information. The benefit is that the error bounds are typically reasonably propagated and the computation is reasonably fast. The drawback is that it is an approximation and will be not correct, if the uncertainty is too large and/or the signals change too quickly (for example are discontinuous).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The following model defines a simple pendulum where a mass point is attached via a rod and a revolute joint to the environment. It is described by the equations","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"beginaligned\r\n     fracdvarphidt = omega \r\n     0 = m cdot L^2 cdot fracdomegadt + d cdot omega + m cdot g cdot L cdot sin(varphi)\r\nendaligned","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"where varphi is the rotation angle, omega the angular velocity, m the mass, L the rod length, d a damping constant and g the gravity constant. This model can be defined with the commands:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Pendulum = Model(\r\n   L = (0.8±0.1)u\"m\",\r\n   m = (1.0±0.1)u\"kg\",\r\n   d = (0.5±0.05)u\"N*m*s/rad\",\r\n   g = 9.81u\"m/s^2\",\r\n   phi = Var(init = (pi/2±0.1)*u\"rad\"),\r\n   w   = Var(init = 0u\"rad/s\"),\r\n   equations = :[\r\n          w = der(phi)\r\n        0.0 = m*L^2*der(w) + d*w + m*g*L*sin(phi)\r\n   ]\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum, FloatType=Measurements.Measurement{Float64})\r\nsimulate!(pendulum, Tsit5(), stopTime = 10.0)\r\nplot(pendulum, \"phi\")","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"and simulates the pendulum with uncertain parameter and init values and results in the following plot:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: PendulumWithUncertaintities)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The area around the nominal value of a variable characterizes the standard deviation.","category":"page"},{"location":"Tutorial.html#.3-Monte-Carlo-Simulation","page":"TinyModia Tutorial","title":"4.3 Monte-Carlo Simulation","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The Julia package MonteCarloMeasurements.jl provides calculations with particles. A value can be defined with a distribution of say 2000 values randomly chosen according to a desired distribution and then all calculations are performed with 2000 values at the same time (corresponds to 2000 simulations that are carried out).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"In the example below, a modest form of 100 particles (100 simulations) with Uniform distributions of some parameters and init values are defined that correspond roughly to the definition with uncertainties of the previous section (but using uniform instead for normal distributions):","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"using TinyModia\r\nusing DifferentialEquations\r\nusing ModiaPlot\r\nusing MonteCarloMeasurements\r\nusing Distributions\r\nusing Unitful\r\n\r\nconst nparticles = 100\r\nuniform(vmin,vmax) = StaticParticles(nparticles,Distributions.Uniform(vmin,vmax))\r\n\r\nPendulum = Model(\r\n   L = uniform(0.6, 1.0),\r\n   m = uniform(0.8, 1.2),\r\n   d = uniform(0.4, 0.6),\r\n   g = 9.81,\r\n   phi = Var(init = uniform(pi/2-0.2, pi/2+0.2)),\r\n   w   = Var(init = 0),\r\n   equations = :[\r\n          w = der(phi)\r\n        0.0 = m*L^2*der(w) + d*w + m*g*L*sin(phi)\r\n   ]\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum,FloatType=StaticParticles{Float64,nparticles})\r\nsimulate!(pendulum, Tsit5(), stopTime = 10.0)\r\nplot(pendulum, \"phi\", MonteCarloAsArea=false)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The simulation result is shown in the next figure:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"(Image: PendulumWithMonteCarlo.png)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Since plot option MonteCarloAsArea=false is used, all 100 simulations are shown in the plot, together with the mean value of all simulations. The default plot behavior is to show the mean value and the area in which all simulations are contained (this is useful, if there are much more simulations, because GLMakie crashes when there are too many curves in a diagram).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"There are currently a few restrictions, in particular units are not yet supported in the combination of TinyModia and MonteCarloMeasurements, so units are not defined in the model above.","category":"page"},{"location":"Tutorial.html#Appendix-A","page":"TinyModia Tutorial","title":"Appendix A","text":"","category":"section"},{"location":"Tutorial.html#A.1-Var-constructor","page":"TinyModia Tutorial","title":"A.1 Var constructor","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The constructor Var(..) defines attributes of a variable with key/value pairs. In column 1 the keys are shown. The default is that none of the keys are defined (meaning key = nothing). Most of the keys are also provided as predefined constants as shown in column 2 and 3. These constants can be used as shortcuts:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Var key ShortCut Shortcut value Description\nparameter parameter Var(parameter = true) If true, value is fixed during simulation\ninput input Var(input = true) If true, input signal\noutput output Var(output = true) If true, output signal\npotential potential Var(potential = true) If true, potential variable\nflow flow Var(flow = true) If true, flow variable\ninit – – Initial value of ODE state (defines unit and size)\nstart – – Start value of variable (defines unit and size)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Example:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"v = output | Var(start = zeros(3)u\"N*m\")\r\n\r\n# Same as: v = Var(output = true, start = zeros(3)u\"N*m\")","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"An attribute can be removed by using a value of nothing. Example:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"System1 = Model(v = input | Var(init = 1.0), ...)\r\n\r\n# System2 = Model(v = input, ...)\r\nSystem2 = System1 | Map(v = Var(init = nothing), ...)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The following attributes are also defined for constructor Var, but have no effect yet. Using min, max, info already now, might be useful for model libraries:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Var Key Shortcut Shortcut value Description\nconstant constant Var(constant = true) If true, value cannot be changed\nmin, max interval(a,b) Var(min = a, max = b) Allowed variable value range\ninfo info\"...\" Var(info=\"...\") Description","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Example:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"v = output | interval(0.0,1.0) | Var(start = zeros(3)u\"N*m\") | info\"An output variable\"\r\n\r\n# Same as: v = Var(output = true, min = 0.0, max = 1.0,\r\n#                  start = zeros(3)u\"N*m\", info = \"An output variable\")","category":"page"},{"location":"Tutorial.html#A.2-Named-tuples-and-quoted-expressions","page":"TinyModia Tutorial","title":"A.2 Named tuples and quoted expressions","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The fundamental mechanism for defining models in TinyModia are named tuples which is a list of key/value pairs enclosed in parentheses:","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"julia> S=(p=5, q=10)\r\n(p = 5, q = 10)\r\n\r\njulia> typeof(S)\r\nNamedTuple{(:p, :q),Tuple{Int64,Int64}}","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Named tuples are conceptually similar to dictionaries (Dict), but the constructor syntax is simpler. Note that if only one key/value pair is given, a comma must preceed the final parentheses: (p = 5, ). It is also possible to define named tuples using a keyword argument list, i.e. a list starting with a semi-colon: z=(;p=5).","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The values can also be a quoted expression, i.e. an expression enclosed in :( ), an array of quoted expressions encloded in :[ ] or just a quoted symbol, :x. This mechanism is used to encode equations and expressions of the model which needs to be manipulated before the model can be simulated.","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"Julia defines a very useful merge operation between named tuples (and dictionaries):","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"julia> T=(q=100, r=200)\r\n(q = 100, r = 200)\r\n\r\njulia> merge(S, T)\r\n(p = 5, q = 100, r = 200)","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"If a key already exists q in the first named tuple, it's value is overwritten otherwise it's added, r. Such a merge semantics allows for unification of parameter modifications and inheritance as will be demonstrated below.","category":"page"},{"location":"Tutorial.html#A.3-MergeModels-algorithm","page":"TinyModia Tutorial","title":"A.3 MergeModels algorithm","text":"","category":"section"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"The mergeModels algorithm is defined as follows (without logging):","category":"page"},{"location":"Tutorial.html","page":"TinyModia Tutorial","title":"TinyModia Tutorial","text":"function mergeModels(m1::NamedTuple, m2::NamedTuple, env=Symbol())\r\n    mergedModels = OrderedDict{Symbol,Any}(pairs(m1)) # Convert the named tuple m1 to an OrderedDict\r\n    for (k,v) in collect(pairs(m2))\r\n        if typeof(v) <: NamedTuple\r\n            if k in keys(mergedModels) && ! (:_redeclare in keys(v))\r\n                mergedModels[k] = mergeModels(mergedModels[k], v, k)\r\n            else\r\n                mergedModels[k] = v\r\n            end\r\n        elseif v === nothing\r\n            delete!(mergedModels, k)\r\n        else\r\n            mergedModels[k] = v\r\n        end\r\n    end\r\n    return (; mergedModels...) # Transform OrderedDict to named tuple\r\nend\r\n\r\n|(m::NamedTuple, n::NamedTuple) =  mergeModels(m, n)\r\n\r\nRedeclare = ( _redeclare = true, )","category":"page"},{"location":"Functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = TinyModia","category":"page"},{"location":"Functions.html#Instantiation","page":"Functions","title":"Instantiation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"@instantiateModel\r\ninstantiateModel","category":"page"},{"location":"Functions.html#TinyModia.@instantiateModel","page":"Functions","title":"TinyModia.@instantiateModel","text":"modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,\n    log=false, logModel=false, logDetails=false, logStateSelection=false, logCode=false, logExecution=false, logTiming=false)\n\nInstantiates a model, i.e. performs structural and symbolic transformations and generates a function for calculation of derivatives suitable for simulation.\n\nmodel: model (declarations and equations)\nFloatType: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}\naliasReduction: Perform alias elimination and remove singularities\nunitless: Remove units (useful while debugging models and needed for MonteCarloMeasurements)\nlog: Log the different phases of translation\nlogModel: Log the variables and equations of the model\nlogDetails: Log internal data during the different phases of translation\nlogStateSelection: Log details during state selection\nlogCode: Log the generated code\nlogExecution: Log the execution of the generated code (useful for finding unit bugs)\nlogTiming: Log timing of different phases\nreturn modelInstance prepared for simulation\n\n\n\n\n\n","category":"macro"},{"location":"Functions.html#TinyModia.instantiateModel","page":"Functions","title":"TinyModia.instantiateModel","text":"See documentation of macro @instatiateModel\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Simulation","page":"Functions","title":"Simulation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"simulate!","category":"page"},{"location":"Functions.html#TinyModia.simulate!","page":"Functions","title":"TinyModia.simulate!","text":"simulate!(model [, algorithm]; merge = nothing,\n          tolerance = 1e-6, startTime = 0.0, stopTime = 1.0, interval = NaN,\n          adaptive = true, log = true, logParameters = true, logStates = true,\n          requiredFinalStates = nothing)\n\nSimulate model::SimulationModel with algorithm (= alg of ODE Solvers of DifferentialEquations.jl). If the algorithm argument is missing, a default algorithm will be chosen from DifferentialEquations (for details see https://arxiv.org/pdf/1807.06430, Figure 3).\n\nThe simulation results stored in model can be plotted with ModiaPlot.plot and the result values can be retrieved with get_result.\n\nOptional Arguments\n\nmerge: Define parameters and init/start values that shall be merged with the previous values          stored in model, before simulation is started.  \ntolerance: Relative tolerance.\nstartTime: Start time. If value is without unit, it is assumed to have unit [s].\nstopTime: Stop time. If value is without unit, it is assumed to have unit [s].\ninterval: Interval to store result. If interval=NaN, it is internally selected as             (stopTime-startTime)/500.             If value is without unit, it is assumed to have unit [s].\nadaptive: = true, if the algorithm should use step-size control (if available).             = false, if the algorithm should use a fixed step-size of interval (if available).\nlog: = true, to log the simulation.\nlogParameters: = true, to log the parameter and init/start values\nlogStates : = true, to log the states, its init/start values and its units.\nrequiredFinalStates: is not nothing: Check whether the ODE state vector at the final time instant with @test             is in agreement to vector requiredFinalStates with respect to some tolerance. If this is not the case, print the             final state vector (so that it can be included with copy-and-paste in the simulate!(..) call).\n\nExamples\n\nusing ModiaPlot\nusing DifferentialEquations\n\n# Define model\ninputSignal(t) = sin(t)\n\nFirstOrder = Model(\n    T = 0.2,\n    x = Var(init=0.3),\n    equations = :[u = inputSignal(time/u\"s\"),\n                  T * der(x) + x = u,\n                  y = 2*x]\n)\n\n# Modify parameters and initial values of model\nFirstOrder2 = FirstOrder | Map(T = 0.4, x = Var(init=0.6))\n\n# Instantiate model\nfirstOrder = @instantiateModel(FirstOrder2, logCode=true)\n\n\n# Simulate with automatically selected algorithm and \n# modified parameter and initial values\nsimulate!(firstOrder, stopTime = 1.0, merge = Map(T = 0.6, x = 0.9), logParameters=true)\n\n# Plot variables \"x\", \"u\" in diagram 1, \"der(x)\" in diagram 2, both diagrams in figure 3\nplot(firstOrder, [(\"x\",\"u\"), \"der(x)\"], figure=3)\n\n# Retrieve \"time\" and \"u\" values:\nget_result(firstOrder, \"time\")\nget_result(firstOrder, \"u\")\n    \n    \n# Simulate with Runge-Kutta 5/4 with step-size control\nsimulate!(firstOrder, Tsit5(), stopTime = 1.0)\n\n# Simulate with Runge-Kutta 4 with fixed step size\nsimulate!(firstOrder, RK4(), stopTime = 1.0, adaptive=false)\n\n# Simulate with algorithm that switches between \n# Verners Runge-Kutta 6/5 algorithm if non-stiff region and\n# Rosenbrock 4 (= A-stable method) if stiff region with step-size control\nsimulate!(firstOrder, AutoVern6(Rodas4()), stopTime = 1.0)\n\n# Simulate with Sundials CVODE (BDF method with variable order 1-5) with step-size control\nusing Sundials\nsimulate!(firstOrder, CVODE_BDF(), stopTime = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Plotting","page":"Functions","title":"Plotting","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"The results of a simulation of a model instantiatedModel can be visualized with function ModiaPlot.plot that produces line plots of the result time series. A variable a.b.c is identified by a String key \"a.b.c\". The legends/labels of the plots are automatically constructed by the names and units of the variables. Example:","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"using ModiaPlot\r\ninstantiatedModel = @instantiatedModel(...)\r\nsimulate!(instantiatedModel, ...)\r\nplot(instantiatedModel,\r\n     [ (\"phi\", \"r\")        (\"phi\", \"phi2\", \"w\");\r\n       (\"w\", \"w2\", \"phi2\") \"w\"                ],\r\n     heading=\"Matrix of plots\")","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"generates the following plot:","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"(Image: Matrix-of-Plots)","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"The underlying line plot is generated by GLMakie.","category":"page"},{"location":"Functions.html#Inquiries","page":"Functions","title":"Inquiries","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = TinyModia","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"get_result\r\nget_lastValue","category":"page"},{"location":"Functions.html#TinyModia.get_result","page":"Functions","title":"TinyModia.get_result","text":"signal = get_result(model, name; unit=true)\n\nAfter a successful simulation of model::SimulationModel, return the result for the signal name::String as vector of points together with its unit. The time vector has path name \"time\". If unit=false, the signal is returned, without unit.\n\nExample\n\nusing ModiaBase\nusing Unitful\n\ninclude(\"$(ModiaBase.path)/demos/models/Model_Pendulum.jl\")\nusing  .Model_Pendulum\n\npendulum = simulationModel(Pendulum)\nsimulate!(pendulum, stopTime=7.0)\n\ntime = get_result(pendulum, \"time\")  # vector with unit u\"s\"\nphi  = get_result(pendulum, \"phi\")   # vector with unit u\"rad\"\n\nimport PyPlot\nPyPlot.figure(4)   # Change to figure 4 (or create it, if it does not exist)\nPyPlot.clf()       # Clear current figure\nPyPlot.plot(ustrip(time), ustrip(phi), \"b--\", label=\"phi in \" * string(unit(phi[1])))\nPyPlot.xlabel(\"time in \" * string(unit(time[1])))\nPyPlot.legend()\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#TinyModia.get_lastValue","page":"Functions","title":"TinyModia.get_lastValue","text":"get_lastValue(model::SimulationModel, name::String; unit=true)\n\nReturn the last stored value of variable name from model. If unit=true return the value with its unit, otherwise with stripped unit.\n\nIf name is not known or no result values yet available, an info message is printed and the function returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = ModiaPlot","category":"page"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"hasSignal\r\ngetNames","category":"page"},{"location":"Functions.html#ModiaPlot.hasSignal","page":"Functions","title":"ModiaPlot.hasSignal","text":"hasSignal(result, name)\n\nReturns true if signal name is available in result.\n\n\n\n\n\nModiaPlot.hasSignal(model::SimulationModel, name::String)\n\nReturn true if parameter or time-varying variable name (for example a.b.c) is defined in the TinyModia SimulationModel (generated with TinyModia.@instantiateModel that can be accessed and can be used for plotting.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#ModiaPlot.getNames","page":"Functions","title":"ModiaPlot.getNames","text":"getNames(result)\n\nReturn a vector of the names that are present in result.\n\n\n\n\n\nModiaPlot.getNames(model::SimulationModel)\n\nReturn the variable names (parameters, time-varying variables) of a TinyModia SimulationModel (generated with TinyModia.@instantiateModel that can be accessed and can be used for plotting.\n\n\n\n\n\n","category":"function"},{"location":"index.html#TinyModia-Documentation","page":"Home","title":"TinyModia Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TinyModia is a minimalistic environment in form of a Julia package to model and simulate physical systems (electrical, mechanical, thermo-dynamical, etc.) described by differential and algebraic equations. A user defines a model on a high level with model components (like a mechanical body, an electrical resistance, or a pipe) that are physically connected together. A model component is constructed by \"expression = expression\" equations. The defined model is symbolically processed (for example, equations might be analytically differentiated) with algorithms from package ModiaBase.jl. From the transformed model a Julia function is generated that is used to simulate the model with integrators from DifferentialEquations.jl. The basic type of the floating point variables is usually Float64, but can be set to any type FloatType<:AbstractFloat via @instantiateModel(..., FloatType = xxx), for example it can be set to Float32, DoubleFloat, Measurement{Float64}, StaticParticles{Float64,100}.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package is registered and is installed with (Julia >= 1.5 is required):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add TinyModia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It is recommended to also add the following packages, in order that all tests and examples can be executed in your standard environment:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add ModiaPlot, Unitful, DifferentialEquations, Measurements, MonteCarloMeasurements, Distributions","category":"page"},{"location":"index.html#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.7.1","page":"Home","title":"Version 0.7.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Variable constructor Var(...) introduced. For example: v = input | Var(init = 1.2u\"m\").  For details see section A.1 Var constructor.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions are called in the scope where macro @instantiateModel is called.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"New arguments of function simulate!:\nParameter and init/start values can be changed with argument merge.\nA simulation can be checked with argument requiredFinalStates.\nArgument logParameters lists the parameter and init/start values used for the simulation.\nArgument logStates lists the states, init, and nominal values used for the simulation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"end in array ranges is supported, for example v[2:end].","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"New (small) model library TinyModia/models/HeatTransfer.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TinyModia Tutorial improved.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions docu improved.","category":"page"},{"location":"index.html#Version-0.7.0","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Initial version, based on code developed for Modia 0.6 and ModiaMath 0.6.","category":"page"},{"location":"index.html#Main-developers","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hilding Elmqvist, Mogram.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Martin Otter, DLR - Institute of System Dynamics and Control.","category":"page"}]
}
