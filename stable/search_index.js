var documenterSearchIndex = {"docs":
[{"location":"Internal.html#Internal","page":"Internal","title":"Internal","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This chapter documents internal functions that are typically only for use of the developers of package TinyModia.","category":"page"},{"location":"Internal.html#Code-Generation","page":"Internal","title":"Code Generation","text":"","category":"section"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"This section provides functions to generate Julia code of the transformed equations.","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"CurrentModule = TinyModia","category":"page"},{"location":"Internal.html","page":"Internal","title":"Internal","text":"SimulationModel\r\ngenerate_getDerivatives!\r\ninit!\r\noutputs!\r\naddToResult!\r\ngetFloatType\r\nbaseType\r\nmeasurementToString","category":"page"},{"location":"Internal.html#TinyModia.SimulationModel","page":"Internal","title":"TinyModia.SimulationModel","text":"simulationModel = SimulationModel{FloatType}(\n        modelName, getDerivatives!, equationInfo, x_startValues,\n        parameters, variableNames;\n        vEliminated::Vector{Int}=Int[], vProperty::Vector{Int}=Int[], \n        var_name::Function = v->nothing)\n\nArguments\n\nparameters: A dictionary of (key, value) pairs. A key can be a Symbol or a String.\nvariableNames: A vector of variable names. A name can be a Symbol or a String.\n\n\n\n\n\n","category":"type"},{"location":"Internal.html#TinyModia.generate_getDerivatives!","page":"Internal","title":"TinyModia.generate_getDerivatives!","text":"code = generate_getDerivatives!(AST, equationInfo, parameters, variables, functionName;\n                                hasUnits=false)\n\nReturn the code of the getDerivatives! function as Expr using the Symbol functionName as function name. By eval(code) or  fc = @RuntimeGeneratedFunction(code) the function is compiled and can afterwards be called.\n\nArguments\n\nAST::Vector{Expr}: Abstract Syntax Tree of the equations as vector of Expr.\nequationInfo::ModiaBase.EquationInfo: Data structure returned by `ModiaBase.getSortedAndSolvedAST           holding information about the states.\nparameters: Vector of parameter names (as vector of symbols)\nvariables: Vector of variable names (as vector of symbols). The first entry is expected to be time, so variables[1] = :time.\nfunctionName::Function: The name of the function that shall be generated.\n\nOptional Arguments\n\nhasUnits::Bool: = true, if variables have units. Note, the units of the state vector are defined in equationinfo.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.init!","page":"Internal","title":"TinyModia.init!","text":"init!(simulationModel, startTime)\n\nInitialize simulationModel::SimulationModel at startTime. In particular:\n\nEmpty result data structure\nCall simulationModel.getDerivatives! once with isInitial = true to  compute and store all variables in the result data structure at startTime and initialize simulationModel.linearEquations.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.outputs!","page":"Internal","title":"TinyModia.outputs!","text":"outputs!(x, t, integrator)\n\nDifferentialEquations FunctionCallingCallback function for SimulationModel that is used to store results at communication points.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.addToResult!","page":"Internal","title":"TinyModia.addToResult!","text":"addToResult!(simulationModel, variableValues...)\n\nAdd variableValues... to simulationModel::SimulationModel. It is assumed that the first variable in variableValues is time.\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.getFloatType","page":"Internal","title":"TinyModia.getFloatType","text":"floatType = getFloatType(simulationModel::SimulationModel)\n\nReturn the floating point type with which simulationModel is parameterized (for example returns: Float64, Float32, DoubleFloat, Measurements.Measurement{Float64}).\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.baseType","page":"Internal","title":"TinyModia.baseType","text":"baseType(T)\n\nReturn the base type of a type T.\n\nExamples\n\nbaseType(Float32)                # Float32\nbaseType(Measurement{Float64})   # Float64\n\n\n\n\n\n","category":"function"},{"location":"Internal.html#TinyModia.measurementToString","page":"Internal","title":"TinyModia.measurementToString","text":"str = measurementToString(v)\n\nReturn variable v::Measurements.Measurement{FloatType} or a vector of such variables in form of a string will the full number of significant digits.\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"CurrentModule = TinyModia","category":"page"},{"location":"Functions.html#Instanciation","page":"Functions","title":"Instanciation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"@instantiateModel\r\ninstantiateModel","category":"page"},{"location":"Functions.html#TinyModia.@instantiateModel","page":"Functions","title":"TinyModia.@instantiateModel","text":"modelInstance = @instantiateModel(model; FloatType = Float64, aliasReduction=true, unitless=false,\n    log=false, logModel=false, logDetails=false, logStateSelection=false, logCode=false, logExecution=false, logTiming=false)\n\nInstantiates a model, i.e. performs structural and symbolic transformations and generates a function for calculation of derivatives suitable for simulation.\n\nmodel: model (declarations and equations)\nFloatType: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}\naliasReduction: Perform alias elimination and remove singularities\nunitless: Remove units (useful while debugging models and needed for MonteCarloMeasurements)\nlog: Log the different phases of translation\nlogModel: Log the variables and equations of the model\nlogDetails: Log internal data during the different phases of translation\nlogStateSelection: Log details during state selection\nlogCode: Log the generated code\nlogExecution: Log the execution of the generated code (useful for finding unit bugs)\nlogTiming: Log timing of different phases\nreturn modelInstance prepared for simulation \n\n\n\n\n\n","category":"macro"},{"location":"Functions.html#TinyModia.instantiateModel","page":"Functions","title":"TinyModia.instantiateModel","text":"See documentation of macro @instatiateModel\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#Simulation","page":"Functions","title":"Simulation","text":"","category":"section"},{"location":"Functions.html","page":"Functions","title":"Functions","text":"simulate!\r\nget_result","category":"page"},{"location":"Functions.html#TinyModia.simulate!","page":"Functions","title":"TinyModia.simulate!","text":"simulate!(model [, algorithm];\n          tolerance=1e-6, startTime=0.0, stopTime=1.0, interval=NaN, \n          adaptive=true, log=true, requiredFinalStates=nothing)\n\nSimulate model::SimulationModel with algorithm  (= alg of ODE Solvers of DifferentialEquations.jl). If the algorithm argument is missing, a default algorithm will be chosen from DifferentialEquations (for details see https://arxiv.org/pdf/1807.06430, Figure 3).\n\nThe simulation results stored in model can be plotted with ModiaPlot.plot and the result values can be retrieved with get_result.\n\nOptional Arguments\n\ntolerance: Relative tolerance.\nstartTime: Start time. If value is without unit, it is assumed to have unit [s].\nstopTime: Stop time. If value is without unit, it is assumed to have unit [s].\ninterval: Interval to store result. If interval=NaN, it is internally selected as             (stopTime-startTime)/500.             If value is without unit, it is assumed to have unit [s].\nadaptive: = true, if the algorithm should use step-size control (if available).             = false, if the algorithm should use a fixed step-size of interval (if available).\nlog: = true, to log the simulation.\nrequiredFinalStates: is not nothing: Check whether the ODE state vector at the final time instant with @test             is in agreement to vector requiredFinalStates with respect to some tolerance. If this is not the case, print the             final state vector (so that it can be included with copy-and-paste in the simulate!(..) call).\n\nExamples\n\nimport ModiaPlot\nusing  DifferentialEquations\n\n# Runge-Kutta 5/4 with step-size control\nsimulate!(model, DifferentialEquations.Tsit5(), stopTime = 1.0)\n\n    # Plot variables \"v1\", \"v2\" in diagram 1, \"v3\" in diagram 2, both diagrams in figure 3   \n    ModiaPlot.plot(model, [(\"v1\",\"v2\"), \"v3\"], figure=3) \n\n    # Retrieve \"time\" and \"v1\" values:\n    get_result(model, \"time\")\n    get_result(model, \"v1\")\n\n# Runge-Kutta 4 with fixed step size\nsimulate!(model, DifferentialEquations.RK4(), stopTime = 1.0, adaptive=false)\n\n# Switching between Verners Runge-Kutta 6/5 algorithm if non-stiff region and \n# Rosenbrock 4 (= A-stable method) if stiff region with step-size control\nsimulate!(model, AutoVern6(Rodas4()), stopTime = 1.0)\n\n# Automatically selected algorithm\nsimulate!(model, stopTime = 1.0)\n\n# Sundials CVODE (BDF method with variable order 1-5) with step-size control\nusing Sundials\nsimulate!(model, CVODE_BDF(), stopTime = 1.0)\n\n\n\n\n\n","category":"function"},{"location":"Functions.html#TinyModia.get_result","page":"Functions","title":"TinyModia.get_result","text":"signal = get_result(model, name; unit=true)\n\nAfter a successful simulation of model::SimulationModel, return the result for the signal name::String as vector of points together with its unit. The time vector has path name \"time\". If unit=false, the signal is returned, without unit.\n\nExample\n\nusing ModiaBase\nusing Unitful\n\ninclude(\"$(ModiaBase.path)/demos/models/Model_Pendulum.jl\")\nusing  .Model_Pendulum\n\npendulum = simulationModel(Pendulum)\nsimulate!(pendulum, stopTime=7.0)\n\ntime = get_result(pendulum, \"time\")  # vector with unit u\"s\"\nphi  = get_result(pendulum, \"phi\")   # vector with unit u\"rad\"\n\nimport PyPlot\nPyPlot.figure(4)   # Change to figure 4 (or create it, if it does not exist)\nPyPlot.clf()       # Clear current figure\nPyPlot.plot(ustrip(time), ustrip(phi), \"b--\", label=\"phi in \" * string(unit(phi[1])))\nPyPlot.xlabel(\"time in \" * string(unit(time[1])))\nPyPlot.legend()\n\n\n\n\n\n","category":"function"},{"location":"TinyModia.html#Introduction-to-TinyModia","page":"TinyModia","title":"Introduction to TinyModia","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"In this chapter an equation and object based language called TinyModia is defined that is used to evaluate and demonstrate the basic algorithms.","category":"page"},{"location":"TinyModia.html#.1-Equation-oriented-TinyModia-models","page":"TinyModia","title":"2.1 Equation oriented TinyModia models","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"To define models, a constructor Model taking a comma separated list of name/value pairs is used:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A simple differential equation","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"T cdot fracdxdt + x = 2","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"can be defined as:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    using TinyModia\r\n\r\n    SimpleModel = Model(\r\n        T = 0.2,\r\n        equation = :(T * der(x) + x = 2),\r\n    )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The model consist of a definition of a parameter T and one equation. An equation can have a Julia expression on both sides of the equal sign. This model will be symbolically solved for the derivative der(x) before simulation, so the following equation will be used for the integration:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"fracdxdt = (2 - x)  T","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A low pass filter block with input u and output y","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     y = x \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"can be defined as:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    using ModiaBase\r\n\r\n    LowPassFilter = Model(\r\n        T = 0.2,\r\n        inputs = :[u],\r\n        outputs = :[y],\r\n        init = Map(x=0),\r\n        equation = :[T * der(x) + x = u],\r\n        y = :x,\r\n    )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The init key defines the initial condition of the state x to 0. A constructor Map is used. If an equation has just a unique variable in the left hand side, this variable can be used as a key and the corresponding value is the left hand side of the equation given as a quoted expression y = :x.","category":"page"},{"location":"TinyModia.html#.2-Merging-models","page":"TinyModia","title":"2.2 Merging models","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"It is possible to combine models by merging. If we want to change the model to become a high passfilter, an alternative output equation","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"y = -x + u","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"is defined in an anonymous Model Model( y = :(-x + u) ). The merging can in this case be made with the Julia merge function:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"HighPassFilter = merge(LowPassFilter, Model( y = :(-x + u) ) )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"In general, also recursive merging is desired and TinyModia provides a mergeModels function for that (see appendix 2). This function can also be invoked as a binary operator | (also used for merge in Python). Note, that the order of the arguments/operands are important.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Generalizing the block to have two outputs for both low and high pass filtering would be done as follows:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"LowAndHighPassFilter = LowPassFilter | Model(\r\n        outputs = :[low, high],\r\n        y = nothing,\r\n        low = :x,\r\n        high = :(-x + u)\r\n    )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The equation for y is removed by \"assigning\" nothing and two variables are defined and declared as outputs. Model LowAndHighPassFilter represents the following equations:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"beginaligned\r\nT cdot fracdxdt + x = u\r\n     low = x \r\n    high = -x + u \r\nx(t_0) = 0\r\nendaligned","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"By turning on logging of merging setLogMerge(true), the translator gives the log:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Changing: outputs = [y] to outputs = [low, high]\r\nDeleting: y\r\nAdding: low = x\r\nAdding: high = -x + u","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The resulting model is pretty printed by calling @showModel(LowAndHighPassFilter):","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"LowAndHighPassFilter = Model(\r\n  T = 0.2,\r\n  inputs = [u],\r\n  outputs = [low, high],\r\n  init = (\r\n    x = 0,\r\n  ),\r\n  equations = [T * der(x) + x = u],\r\n  low = x,\r\n  high = -x + u,\r\n),","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"In order to test such an input/output block, an input needs to be defined. This can be made by adding an equation for u. Assume we want u to be sinousoidial with an increasing frequency:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"using Unitful\r\n\r\nTestLowAndHighPassFilter = LowAndHighPassFilter | Model(\r\n        w = :((time+1u\"s\")*u\"1/s/s\"),\r\n        u = :(sin(w*time)*u\"V\"),\r\n        init = Map(x=0.2u\"V\")\r\n    )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"time is a reserved name for the independent variable. It has unit s for seconds. The Julia package Unitful provides a means for defining units and managing unit inference. Definition of units is done with a string macro u\"...\". In this case, the input signal was given unit Volt. The state x must then also have consistent unit, i.e. Volt. If the model equations contain systems of simultaneous equations, then approximate guess values, optionally with units, must be given start: start = Map(i=0.0u\"A\").","category":"page"},{"location":"TinyModia.html#.3-Hierarchical-modeling","page":"TinyModia","title":"2.3 Hierarchical modeling","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Sofar, the composition of models have resulted in named tuples with values being numeric values or quoted expressions. Hierarchical models are obtained if the values themself are named tuples. A model with two filters can, for example, be defined as follows:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"TwoFilters = (\r\n    high = HighPassFilter,\r\n    low = LowPassFilter,\r\n)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Note, that the previous definitions of HighPassFilter and LowPassFilter was used instead of making the defintions inline.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A band pass filter is a series connection of a high pass filter and a low pass filter and is described below:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"BandPassFilter = (\r\n    inputs = :[u],\r\n    outputs = :[y],\r\n    high = HighPassFilter | Map(T=0.5),\r\n    low = LowPassFilter | Map(T=2.0),\r\n    equations = :[\r\n        high.u = u,\r\n        low.u = high.y,\r\n        y = low.y]\r\n)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A new input have been defined which is propagated to high.u. The series connection itself is obtained by the equation low.u = high.y. Note, that dot-notation is allowed in equations.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The input and output for the BandPassFilter when using the same input definition as for the TestLowPassFilter is shown below:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"(Image: Band Pass Filter Plot)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The above examples are available in file SimpleFilters.jl.","category":"page"},{"location":"TinyModia.html#.4-Physically-oriented-modeling","page":"TinyModia","title":"2.4 Physically oriented modeling","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Sofar, only signal flow modeling has been used, i.e. input/output blocks coupled with equations between outputs and inputs. For object oriented modeling more high level constructs are neccessary. Coupling is then acausal and involves potentials such as electric potential, positions, pressure, etc. and flows such as electric current, forces and torques and mass flow rate.","category":"page"},{"location":"TinyModia.html#.4.1-Connectors","page":"TinyModia","title":"2.4.1 Connectors","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Models which contain any flow variable, i.e. included in the list flows, are considered connectors. Connectors must have equal number of flow and potential variables, i.e. included in the list potentials, and have matching array sizes. Connectors may not have any equations. An example of an electrical connector with potential (in Volt) and current (in Ampere) is shown below.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Pin = Model( potentials = :[v], flows = :[i] )","category":"page"},{"location":"TinyModia.html#.4.2-Components","page":"TinyModia","title":"2.4.2 Components","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Components are declared in a similar ways as blocks. However, the interfaces between components are defined using connector instances.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"An electrical resistor can be descibed as follows:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Resistor = Model(\r\n    R = 1.0u\"Ω\",\r\n    p = Pin,\r\n    n = Pin,\r\n    equations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i\r\n        R*i = v ]\r\n    )","category":"page"},{"location":"TinyModia.html#.4.3-Inheritance","page":"TinyModia","title":"2.4.3 Inheritance","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Various physical components sometimes share common properties. One mechanism to handle this is to use inheritance. In TinyModia, merging is used.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Electrical components such as resistors, capacitors and inductors are categorized as oneports which have two pins. Common properties are: constraint on currents at the pins and definitions of voltage over the component and current through the component.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"OnePort = Model(\r\n    p = Pin,\r\n    n = Pin,\r\n    equations = :[\r\n        0 = p.i + n.i\r\n        v = p.v - n.v\r\n        i = p.i ] )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Having such a OnePort definition makes it convenient to define electrical component models by merging OnePort with specific parameter definitions with default values and equations:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Resistor = OnePort | Model( R = 1.0u\"Ω\", equation = :[ R*i = v ], )\r\n\r\nCapacitor = OnePort | Model( C = 1.0u\"F\", init=Map(v=0.0u\"V\"), equation = :[ C*der(v) = i ] )\r\n\r\nInductor = OnePort | Model( L = 1.0u\"H\", init=Map(i=0.0u\"A\"), equation = :[ L*der(i) = v ] )\r\n\r\nConstantVoltage = OnePort | Model( V = 1.0u\"V\", equation = :[ v = V ] )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The merged Resistor is shown below:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Resistor = Model(\r\n  p = (\r\n    potentials = [v],\r\n    flows = [i],\r\n  ),\r\n  n = (\r\n    potentials = [v],\r\n    flows = [i],\r\n  ),\r\n  equations = [v = p.v - n.v; 0 = p.i + n.i; i = p.i],\r\n  R = 1.0 Ω,\r\n  equation = [R * i = v],\r\n),","category":"page"},{"location":"TinyModia.html#.4.4-Connections","page":"TinyModia","title":"2.4.4 Connections","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Connections are described as an array of tuples listing the connectors that are connected:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    ( <connect reference 1>, <connect reference 2>, ... )","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A connect reference has either the form 'connect instance name' or 'component instance name'.'connect instance name' with 'connect instance name' being either a connector instance, input or output variable.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Examples","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    connect = :[\r\n      (V.p, R1.p)\r\n      (R1.n, p)\r\n      (C1.n, V.n, R2.p)\r\n      ...\r\n    ]","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"For connectors, all the potentials of the connectors in the same connect tuple are set equal and the sum of all incoming flows to the model are set equal to the sum of the flows into sub-components.","category":"page"},{"location":"TinyModia.html#.4.5-Connected-models","page":"TinyModia","title":"2.4.5 Connected models","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Having the above electrical component models, enables defining a filter","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"(Image: Filter Circuit)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"by instanciating components, setting parameters and defining connections.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Filter = (\r\n    R = Resistor | Map(R=0.5u\"Ω\"),\r\n    C = Capacitor | Map(C=2.0u\"F\"),\r\n    V = ConstantVoltage | Map(V=10.0u\"V\"),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The connect tuples are translated to:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"  V.p.v = R.p.v\r\n  V.p.i + R.p.i = 0\r\n  R.n.v = C.p.v\r\n  R.n.i + C.p.i = 0\r\n  C.n.v = V.n.v\r\n  C.n.i + V.n.i = 0","category":"page"},{"location":"TinyModia.html#.4.6-Parameter-propagation","page":"TinyModia","title":"2.4.6 Parameter propagation","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Hierarchical modification of parameters is powerful but sometimes a bit inconvenient. It is also possible to propagate parameters intoduced on a high level down in the hierarchy. The following Filter model defines three parameters, r, c and v. The r parameter is used to set the resistance of the resistor R: Map(R=:(up.r)). A special notation up. is used to denote that r should not be searched within the resistor, but in the enclosing model, i.e. Filter.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Filter = Model(\r\n    r = 1.0u\"Ω\",\r\n    c = 1.0u\"F\",\r\n    v = 1.0u\"V\",\r\n    R = Resistor | Map(R=:(up.r)),\r\n    C = Capacitor | Map(C=:(up.c)),\r\n    V = ConstantVoltage | Map(V=:(up.v)),\r\n    connect = :[\r\n      (V.p, R.p)\r\n      (R.n, C.p)\r\n      (C.n, V.n)\r\n    ]\r\n)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Two separate filters can then be defined with:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"TwoFilters = Model( f1 = Filter | Map( r = 10.0, c = 2.0), f2 = Filter )","category":"page"},{"location":"TinyModia.html#.4.7-Redeclarations","page":"TinyModia","title":"2.4.7 Redeclarations","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"It is possible to reuse a particular model topology by redeclaring the model of particular components. For example, changing the filter f1 to a voltage divider by changing C from a Capacitor to a Resistor. A predefined model Redeclare is used for this purpose.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"VoltageDividerAndFilter = TwoFilters | Map(f1 = Map(C = Redeclare | Resistor | Map(R = 20.0)))","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"By using Redeclare, a new model based on a Resistor is used for C and the usual merge semantics with the previously defined model of C is not used.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The above examples are available in file FilterCircuit.jl.","category":"page"},{"location":"TinyModia.html#Simulation","page":"TinyModia","title":"3 Simulation","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"A particular model needs to be instantiated and simulated.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    using ModiaBase\r\n    using ModiaPlot\r\n\r\n    filter = @instantiateModel(Filter)\r\n    simulate!(filter, stopTime=10.0)\r\n    plot(filter, \"y\", figure=1)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The @instantiateModel macro takes additional arguments: ","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    modelInstance = @instantiateModel(model; modelName=\"\", modelModule=nothing, FloatType = Float64, aliasReduction=true, unitless=false,\r\n        log=false, logModel=false, logDetails=false, logStateSelection=false, logCode=false, logExecution=false, logTiming=false)\r\n    \r\nInstantiates a model, i.e. performs structural and symbolic transformations and generates a function for calculation of derivatives suitable for simulation.\r\n\r\n* `model`: model (declarations and equations)\r\n* `FloatType`: Variable type for floating point numbers, for example: Float64, Measurements{Float64}, StaticParticles{Float64,100}, Particles{Float64,2000}\r\n* `aliasReduction`: Perform alias elimination and remove singularities\r\n* `unitless`: Remove units (useful while debugging models and needed for MonteCarloMeasurements)\r\n* `log`: Log the different phases of translation\r\n* `logModel`: Log the variables and equations of the model\r\n* `logDetails`: Log internal data during the different phases of translation\r\n* `logStateSelection`: Log details during state selection\r\n* `logCode`: Log the generated code\r\n* `logExecution`: Log the execution of the generated code (useful for finding unit bugs)\r\n* `logTiming`: Log timing of different phases\r\n* `return modelInstance prepared for simulation` ","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The simulation is performed with DifferentialEquations.jl using the default integrator that this package automatically selects. The simulation result is stored inside the filter object and can be plotted with ModiaPlot.plot.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"It is also possible to specify the integrator as second argument of simulate!:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"    using ModiaBase\r\n    using DifferentialEquations\r\n    using ModiaPlot\r\n\r\n    filter = @instantiateModel(Filter)\r\n    simulate!(filter, Tsit5(), stopTime=10.0)\r\n    plot(filter, [\"y\", \"x\"], figure=1)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Integrator DifferentialEquations.Tsit5 is an adaptive Runge-Kutta method of order 5/4.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"For more information, see the documentation of simulate! and the documentation of the ModiaPlot package.","category":"page"},{"location":"TinyModia.html#Appendix","page":"TinyModia","title":"Appendix","text":"","category":"section"},{"location":"TinyModia.html#Named-tuples-and-quoted-expressions","page":"TinyModia","title":"1 Named tuples and quoted expressions","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The fundamental mechanism for defining models in TinyModia are named tuples which is a list of key/value pairs enclosed in parentheses:","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"julia> S=(p=5, q=10)\r\n(p = 5, q = 10)\r\n\r\njulia> typeof(S)\r\nNamedTuple{(:p, :q),Tuple{Int64,Int64}}","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Named tuples are conceptually similar to dictionaries (Dict), but the constructor syntax is simpler. Note that if only one key/value pair is given, a comma must preceed the final parentheses: (p = 5, ). It is also possible to define named tuples using a keyword argument list, i.e. a list starting with a semi-colon: z=(;p=5).","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The values can also be a quoted expression, i.e. an expression enclosed in :( ), an array of quoted expressions encloded in :[ ] or just a quoted symbol, :x. This mechanism is used to encode equations and expressions of the model which needs to be manipulated before the model can be simulated.","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"Julia defines a very useful merge operation between named tuples (and dictionaries):","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"julia> T=(q=100, r=200)\r\n(q = 100, r = 200)\r\n\r\njulia> merge(S, T)\r\n(p = 5, q = 100, r = 200)","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"If a key already exists q in the first named tuple, it's value is overwritten otherwise it's added, r. Such a merge semantics allows for unification of parameter modifications and inheritance as will be demonstrated below.","category":"page"},{"location":"TinyModia.html#Mergemodel-algorithm","page":"TinyModia","title":"2 Mergemodel algorithm","text":"","category":"section"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"The mergeModel algorithm is defined as follows (without logging):","category":"page"},{"location":"TinyModia.html","page":"TinyModia","title":"TinyModia","text":"function mergeModels(m1::NamedTuple, m2::NamedTuple, env=Symbol())\r\n    mergedModels = OrderedDict{Symbol,Any}(pairs(m1)) # Convert the named tuple m1 to an OrderedDict\r\n    for (k,v) in collect(pairs(m2))\r\n        if typeof(v) <: NamedTuple\r\n            if k in keys(mergedModels) && ! (:_redeclare in keys(v))\r\n                mergedModels[k] = mergeModels(mergedModels[k], v, k)\r\n            else\r\n                mergedModels[k] = v\r\n            end\r\n        elseif v === nothing\r\n            delete!(mergedModels, k)\r\n        else\r\n            mergedModels[k] = v\r\n        end\r\n    end\r\n    return (; mergedModels...) # Transform OrderedDict to named tuple\r\nend\r\n\r\n|(m::NamedTuple, n::NamedTuple) =  mergeModels(m, n)\r\n\r\nRedeclare = ( _redeclare = true, )","category":"page"},{"location":"index.html#TinyModia-Documentation","page":"Home","title":"TinyModia Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TinyModia is a minimalistic environment in form of a Julia package to model and simulate physical systems (electrical, mechanical, thermo-dynamical, etc.) described by differential and algebraic equations. A user defines a model on a high level with model components (like a mechanical body, an electrical resistance, or a pipe) that are physically connected together. A model component is constructed by \"expression = expression\" equations. The defined model is symbolically processed (for example, equations might be analytically differentiated) with algorithms from package ModiaBase.jl. From the transformed model a Julia function is generated that is used to simulate the model with integrators from DifferentialEquations.jl. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The basic type of the floating point variables is usually Float64, but can be set to any type T<:AbstractFloat, for example Float32, DoubleFloats.DoubleFloat, Measurements.Measurement{Float64}, MonteCarloMeasurements.StaticParticles{Float64,100} via @instantiateModel(..., FloatType = xxx).","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The package is currently being registered. During this phase, it is installed as (Julia >= 1.5 is required):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add https://github.com/ModiaSim/TinyModia.jl#main","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"It is recommended to also add the following packages, in order that all tests and examples can be executed:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add Unitful, Measurements, MonteCarloMeasurements, Distributions","category":"page"},{"location":"index.html#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.7.0","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Initial version, based on code developed for Modia 0.6 and ModiaMath 0.6.","category":"page"},{"location":"index.html#Main-developers","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Hilding Elmqvist (Mogram AB)\nMartin Otter (DLR - Institute of System Dynamics and Control","category":"page"}]
}
